#!/usr/bin/env python3
"""
Categorize unimplemented functions as either:
1. Empty/funclets (auto-generated by compiler)
2. Destructors with delete
3. SEH funclets
4. Developer code (needs documentation)
"""

import os
import re

def analyze_function(filepath):
    """Analyze a decompiled function and categorize it."""
    with open(filepath, 'r') as f:
        content = f.read()
    
    # Check if it's a library function
    if 'Library Function - Single Match' in content:
        return 'library', 'Library function'
    
    # Extract address
    addr_match = re.search(r'Address:\s*0x([0-9A-Fa-f]+)', content)
    if not addr_match:
        return 'unknown', 'Cannot parse address'
    
    addr = addr_match.group(1).upper()
    
    # Get function body
    lines = content.split('\n')
    body_lines = []
    in_body = False
    for line in lines:
        if '{' in line:
            in_body = True
        if in_body:
            body_lines.append(line)
    
    body = '\n'.join(body_lines)
    
    # Pattern 1: Empty function (just return)
    if re.search(r'{\s*return;\s*}', body, re.DOTALL):
        return 'empty', 'Empty function (compiler-generated)'
    
    # Pattern 2: SEH funclet (cleanup with unaff_EBP)
    if 'unaff_EBP' in body and re.search(r'FUN_\w+\(\*', body):
        # Check if it's a simple cleanup call
        func_calls = re.findall(r'FUN_\w+', body)
        if len(func_calls) <= 2:  # One cleanup call + maybe a return
            return 'seh_funclet', 'SEH exception handler funclet'
    
    # Pattern 3: Destructor with conditional delete
    if '__thiscall' in content and 'param_1 & 1' in body and 'FUN_00424940' in body:
        return 'destructor', 'Destructor with conditional delete'
    
    # Pattern 4: Simple constructor/initializer
    if '__thiscall' in content and body.count('*(undefined4 *)') >= 2:
        assignments = re.findall(r'\*\(undefined4 \*\)', body)
        if len(assignments) >= 2 and body.count('\n') < 15:
            return 'constructor', 'Simple constructor/initializer'
    
    # Check body size
    significant_lines = [l for l in body_lines if l.strip() and l.strip() not in ['{', '}', 'return;']]
    
    if len(significant_lines) < 5:
        return 'simple', f'Simple function ({len(significant_lines)} significant lines)'
    
    return 'developer', f'Developer code ({len(significant_lines)} significant lines)'

def main():
    code_dir = 'code'
    
    categories = {
        'empty': [],
        'seh_funclet': [],
        'destructor': [],
        'constructor': [],
        'simple': [],
        'library': [],
        'developer': [],
        'unknown': []
    }
    
    # Get all decompiled files
    for filename in os.listdir(code_dir):
        if filename.endswith('.decompiled.txt'):
            filepath = os.path.join(code_dir, filename)
            category, description = analyze_function(filepath)
            
            # Extract address from filename
            addr_match = re.search(r'FUN_([0-9A-F]+)', filename)
            if addr_match:
                addr = addr_match.group(1)
                categories[category].append({
                    'addr': addr,
                    'file': filename,
                    'desc': description
                })
    
    # Print summary
    print("=" * 80)
    print("FUNCTION CATEGORIZATION SUMMARY")
    print("=" * 80)
    
    for cat in ['empty', 'seh_funclet', 'destructor', 'constructor', 'simple', 'library', 'developer', 'unknown']:
        funcs = categories[cat]
        if funcs:
            print(f"\n{cat.upper().replace('_', ' ')} ({len(funcs)} functions):")
            print("-" * 80)
            for func in sorted(funcs, key=lambda x: int(x['addr'], 16))[:20]:  # Show first 20
                print(f"  0x{func['addr']}: {func['desc']}")
            if len(funcs) > 20:
                print(f"  ... and {len(funcs) - 20} more")
    
    print("\n" + "=" * 80)
    print(f"TOTAL: {sum(len(v) for v in categories.values())} functions analyzed")
    print("=" * 80)
    
    # Show which can be marked as complete
    auto_complete = categories['empty'] + categories['seh_funclet'] + categories['destructor'] + categories['constructor']
    print(f"\n‚úÖ Can mark as complete: {len(auto_complete)} functions")
    print(f"üìù Need documentation: {len(categories['developer'])} functions")

if __name__ == '__main__':
    main()
